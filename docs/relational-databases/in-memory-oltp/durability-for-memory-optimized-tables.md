---
title: 메모리 액세스에 최적화된 테이블에 대한 내구성 | Microsoft 문서
description: 메모리 내 OLTP가 트랜잭션 로깅을 사용하고 디스크에 있는 스토리지에 데이터 변경 내용을 저장하여 메모리 최적화 테이블의 완전한 내구성을 제공하는 방법을 알아봅니다.
ms.custom: ''
ms.date: 03/20/2017
ms.prod: sql
ms.prod_service: database-engine
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: d304c94d-3ab4-47b0-905d-3c8c2aba9db6
author: markingmyname
ms.author: maghan
ms.openlocfilehash: 3a268de26245955dd6be838e822f1cb84b693324
ms.sourcegitcommit: d35d0901296580bfceda6e0ab2e14cf2b7e99a0f
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/24/2020
ms.locfileid: "92497025"
---
# <a name="durability-for-memory-optimized-tables"></a>메모리 액세스에 최적화된 테이블에 대한 내구성
 [!INCLUDE [SQL Server](../../includes/applies-to-version/sqlserver.md)]

  [!INCLUDE[hek_2](../../includes/hek-2-md.md)]는 메모리 최적화 테이블에 대한 완전한 내구성을 제공합니다. 메모리 최적화 테이블을 변경한 트랜잭션을 커밋할 때 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]를 사용하면 (디스크 기반 테이블과 마찬가지로) 기본 스토리지를 사용할 수 있는 경우 변경 내용이 영구적이 됩니다(데이터베이스 다시 시작 유지). 내구성의 두 가지 주요 구성 요소는 트랜잭션 로깅 및 디스크상 스토리지에 데이터 변경 내용 저장입니다.  
  
 내구성이 있는 테이블의 크기 제한에 대한 자세한 내용은 [메모리 액세스에 최적화된 테이블에 필요한 메모리 예측](../../relational-databases/in-memory-oltp/estimate-memory-requirements-for-memory-optimized-tables.md)을 참조하세요. 
  
## <a name="transaction-log"></a>트랜잭션 로그  
 디스크 기반 테이블 또는 메모리 최적화 내구성이 있는 테이블에 대한 모든 변경은 하나 이상의 트랜잭션 로그 레코드에 캡처됩니다. 트랜잭션이 커밋될 때 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 는 트랜잭션이 커밋된 애플리케이션 또는 사용자 세션과 통신하기 전에 디스크에 트랜잭션과 관련된 로그 레코드를 씁니다. 이렇게 하면 트랜잭션에 의한 변경 사항이 내구성을 가집니다. 메모리 최적화 테이블에 대한 트랜잭션 로그는 디스크 기반 테이블에서 사용되는 동일한 로그 스트림과 완전히 통합되어 있습니다. 이러한 통합에 따라 기존 트랜잭션 로그 백업, 복구 및 복원 작업이 추가 단계를 필요로 하지 않고 계속 수행될 수 있습니다. 그러나 [!INCLUDE[hek_2](../../includes/hek-2-md.md)] 가 워크로드의 트랜잭션 처리량을 크게 늘릴 수 있기 때문에 로그 IO에 성능 병목 현상이 발생할 수 있습니다. 이 증가한 처리량을 견디기 위해 로그 IO 하위 시스템에서 증가한 로드를 처리할 수 있습니다.  
  
## <a name="data-and-delta-files"></a>데이터 및 델타 파일  
 메모리 최적화 테이블의 데이터는 하나 이상의 인덱스를 통해 연결된 메모리 내 힙 데이터 구조의 자유 형식 데이터 행으로 메모리에 저장됩니다. 디스크 기반 테이블에 사용되는 페이지 구조와 같이 데이터 행에 대한 페이지 구조는 없습니다. 장기 지속성을 위해 그리고 트랜잭션 로그의 잘림을 허용하기 위해 메모리 최적화 테이블은 데이터 및 델타 파일 집합에서 유지됩니다. 이러한 파일은 비동기 백그라운드 프로세스를 사용하여 트랜잭션 로그를 기반으로 생성됩니다. 데이터 및 델타 파일은 (FILESTREAM 데이터에 사용되는 동일한 메커니즘을 사용하는) 하나 이상의 컨테이너에 있습니다. 이러한 컨테이너는 메모리 최적화 파일 그룹의 일부입니다.  
  
 데이터는 이 파일에 기록될 때 회전 미디어의 디스크 대기 시간을 최소화하는 엄격한 순차적 방식으로 기록됩니다. 서로 다른 디스크의 여러 컨테이너를 사용하여 I/O 작업을 분산할 수 있습니다. 서로 다른 디스크의 여러 컨테이너에 있는 데이터 및 델타 파일은 디스크의 데이터 및 델타 파일에서 메모리로 데이터를 읽을 때 데이터베이스 복원/복구 성능을 향상시킵니다.  
  
 사용자 트랜잭션은 데이터 및 델타 파일에 직접 액세스하지 않습니다. 모든 데이터 읽기 및 쓰기에서는 메모리 내 데이터 구조를 사용합니다.  
  
### <a name="the-data-file"></a>데이터 파일  
 데이터 파일에는 여러 트랜잭션에서 삽입 또는 업데이트 작업 중에 삽입된 하나 이상의 메모리 최적화 테이블에서 가져온 행이 포함되어 있습니다. 예를 들어, 메모리 최적화 테이블 T1에서 한 행을 가져오고 메모리 최적화 테이블 T2에서 다음 행을 가져올 수 있습니다. 트랜잭션 로그의 트랜잭션 순서로 데이터 파일에 행을 추가하여 데이터 액세스를 순차적으로 지정합니다. 이렇게 하면 임의 I/O와 비교할 때 상당히 나은 I/O 처리량이 가능합니다.  
  
 데이터 파일이 꽉 차면 새 트랜잭션에서 삽입되는 행은 다른 데이터 파일에 저장됩니다. 시간이 지날수록 지속형 메모리 최적화 테이블의 행은 더 많은 데이터 파일 중 하나에 저장되고, 결합되지 않았지만 연속하는 트랜잭션 범위의 행이 각 데이터 파일에 포함됩니다. 예를 들어, 트랜잭션 커밋 타임스탬프 범위가 (100, 200)인 데이터 파일에는 커밋 타임스탬프가 100보다 크고 200보다 작거나 같은 트랜잭션에 의해 삽입된 모든 행이 포함됩니다. 커밋 타임스탬프는 커밋 준비가 되면 트랜잭션에 할당되는 단순하게 증가하는 숫자입니다. 각 트랜잭션에는 고유한 커밋 타임스탬프가 있습니다.  
  
 행을 삭제하거나 업데이트해도 해당 행은 데이터 파일에서 제거되거나 변경되지 않지만 삭제된 행은 다른 파일 형식인 델타 파일로 추적됩니다. 업데이트 작업은 각 행에 대한 삭제 및 삽입 작업의 튜플로 처리됩니다. 따라서 데이터 파일에서 임의의 IO가 제거됩니다.  
 
   크기: 각 데이터 파일의 크기는 16GB보다 메모리가 더 큰 컴퓨터의 경우 약 128MB, 16GB보다 메모리가 더 작거나 같은 컴퓨터의 경우 약 16MB입니다. [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)] 에서 SQL Server는 스토리지 하위 시스템 속도가 충분하다고 판단되는 경우 큰 검사점 모드를 사용할 수 있습니다. 큰 검사점 모드에서 데이터 파일 크기는 1GB로 조정됩니다. 이렇게 하면 처리량이 높은 워크로드에 대한 스토리지 하위 시스템의 효율성을 높일 수 있습니다.  
   
### <a name="the-delta-file"></a>델타 파일  
 각 데이터 파일은 트랜잭션 범위가 동일하고 해당 트랜잭션 범위에서 트랜잭션에 의해 삽입된 삭제된 행을 추적하는 델타 파일과 쌍을 이룹니다. 이 데이터 및 델타 파일은 CFP(검사점 파일 쌍)이라고 하며, 병합 작업을 위한 단위는 물론 할당 및 할당 취소 작업의 단위이기도 합니다. 예를 들어, 트랜잭션 범위 (100, 200)에 해당하는 델타 파일은 범위 (100, 200)의 트랜잭션에 의해 삽입된 삭제된 행을 저장합니다. 데이터 파일과 마찬가지로 델타 파일은 순차적으로 액세스됩니다.  
  
 행이 삭제되면 해당 행은 데이터 파일에서 제거되지 않지만 이 데이터 행이 삽입된 트랜잭션 범위에 연결된 델타 파일에 행에 대한 참조가 추가됩니다. 삭제할 행이 데이터 파일에 이미 있기 때문에 델타 파일은 참조 정보 `{inserting_tx_id, row_id, deleting_tx_id }` 만 원래 삭제 또는 업데이트 작업의 트랜잭션 로그 순서에 따라 저장합니다.  
  

 크기: 각 데이터 파일의 크기는 16GB보다 메모리가 더 큰 컴퓨터의 경우 약 16MB, 16GB보다 메모리가 더 작거나 같은 컴퓨터의 경우 약 1MB입니다. [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)] 부터 SQL Server는 스토리지 하위 시스템 속도가 충분하다고 판단되는 경우 큰 검사점 모드를 사용할 수 있습니다. 큰 검사점 모드에서 델타 파일 크기는 128MB로 조정됩니다.  
 
## <a name="populating-data-and-delta-files"></a>데이터 및 델타 파일 채우기  
 데이터 및 델타 파일은 메모리 최적화 테이블에서 커밋된 트랜잭션에 의해 생성되는 트랜잭션 로그 레코드를 기준으로 채워지고 삽입된 행과 삭제된 행에 대한 정보를 해당 데이터 및 델타 파일에 추가합니다. 검사점이 완료되면 데이터/인덱스 페이지가 임의 I/O로 플러시되는 디스크 기반 테이블과 달리 메모리 최적화 테이블은 계속해서 백그라운드 작업으로 지속됩니다. 트랜잭션을 삭제하거나 이전 트랜잭션에 의해 삽입된 모든 행을 업데이트하기 때문에 여러 개의 델타 파일이 액세스됩니다. 삭제 정보는 항상 델타 파일의 끝에 추가됩니다. 예를 들어, 커밋 타임스탬프가 600인 트랜잭션은 한 행을 삽입하고 아래 그림처럼 150, 250 및 450의 커밋 타임스탬프를 갖는 트랜잭션에 의해 삽입된 행을 삭제합니다. 모두 4번의 파일 I/O 작업(삭제된 행에 3번, 새로 삽입된 행에 1번)이 해당 델타 및 데이터 파일에 대한 추가 전용 작업입니다.  
  
 ![메모리 최적화 테이블에 대한 로그 레코드를 읽습니다.](../../relational-databases/in-memory-oltp/media/read-logs-hekaton.gif "메모리 최적화 테이블에 대한 로그 레코드를 읽습니다.")  
  
## <a name="accessing-data-and-delta-files"></a>데이터 및 델타 파일 액세스  
 데이터 및 델타 파일 쌍은 다음이 발생할 때 액세스됩니다.  
  
 오프라인 검사점 작업자  
 이 스레드는 메모리 최적화 데이터 행을 해당 데이터 및 델타 파일 쌍에 삽입하고 삭제합니다. [!INCLUDE[ssSQL14](../../includes/sssql14-md.md)] 에는 오프라인 검사점 작업자가 하나이며 [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)] 부터는 여러 오프라인 검사점 작업자가 있습니다.  
  
 병합 작업  
 작업은 하나 이상의 데이터 및 델타 파일 쌍을 병합하고 새로운 데이터 및 델타 파일 쌍을 만듭니다.  
  
 충돌 복구 동안  
 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]을 다시 시작하거나 데이터베이스가 다시 온라인이 되면 데이터 및 델타 파일 쌍을 사용하여 메모리 최적화 데이터가 채워집니다. 델타 파일은 해당 데이터 파일에서 행을 읽을 때 삭제된 행에 대한 필터의 역할을 합니다. 각 데이터 및 델타 파일 쌍은 서로 독립적이기 때문에 이러한 파일은 메모리에 데이터를 채우는 데 걸리는 시간을 줄이기 위해 병렬로 로드됩니다. 데이터가 메모리로 로드되면 메모리 내 OLTP 엔진은 메모리 최적화 데이터가 완전하도록 검사점 파일에 아직 포함되지 않은 활성 트랜잭션 로그 레코드를 적용합니다.  
  
 복원 작업 동안  
 메모리 내 OLTP 검사점 파일이 데이터베이스 백업에서 만들어진 다음 하나 이상의 트랜잭션 로그 백업이 적용됩니다. 충돌 복구와 마찬가지로 메모리 내 OLTP 엔진은 데이터를 병렬로 메모리로 로드하여 복구 시간에 미치는 영향을 최소화합니다.  
  
## <a name="merging-data-and-delta-files"></a>데이터 및 델타 파일 병합  
 메모리 액세스에 최적화된 테이블에 대한 데이터는 하나 이상의 데이터 및 델타 파일 쌍(검사점 파일 쌍 또는 CFP 라고도 함)에 저장됩니다. 데이터 파일에는 삽입된 행이 저장되고 델타 파일은 삭제된 행을 참조합니다. OLTP 작업을 실행하는 동안 DML 작업에서는 행을 업데이트, 삽입 및 삭제하고, 새 행을 유지하기 위한 새 CFP가 만들어지고, 삭제된 행에 대한 참조가 델타 파일에 추가됩니다.  
  
 시간이 지날수록 DML 작업으로 데이터 및 델타 파일 수가 증가되어 디스크 공간 사용량이 늘어나고 복구 시간이 증가됩니다.  
  
 이러한 비효율성을 방지하려면 아래에 설명된 병합 정책에 따라 오래된 닫힌 데이터 및 델타 파일을 병합하여 더 적은 수의 파일로 동일한 데이터 집합을 나타내도록 스토리지 배열을 압축합니다.  
  
 병합 작업에서는 내부적으로 정의된 병합 정책에 따라 하나 이상의 인접한 닫힌 CFP(검사점 파일 쌍), 즉 병합 원본이라고 하는 데이터 및 델타 파일 쌍을 입력으로 사용하여 병합 대상이라는 단일 결과 CFP를 생성합니다. 원본 CFP의 각 델타 파일에 있는 항목은 해당 데이터 파일에서 행을 필터링하여 필요 없는 데이터 행을 제거하는 데 사용됩니다. 원본 CFP의 나머지 행은 하나의 대상 CFP로 통합됩니다. 병합이 완료되면 원본 CFP(병합 원본)가 결과 병합 대상 CFP로 대체됩니다. 병합 원본 CFP는 전환 단계를 완료한 후 스토리지에서 제거됩니다.  
  
 아래 예제에서 메모리 최적화 테이블 파일 그룹에는 이전 트랜잭션의 데이터를 포함하는 타임스탬프 500에 4개의 데이터와 델타 파일 쌍이 있습니다. 예를 들어, 첫 번째 데이터 파일의 행은 타임스탬프가 100보다 크고 200보다 작거나 같은 트랜잭션에 해당하며 (100, 200]으로 표시됩니다. 두 번째 및 세 번째 데이터 파일은 삭제된 것으로 표시된 행이 채워진 비율이 50% 미만으로 표시됩니다. 병합 작업에서는 이 두 CFP를 결합하고 타임스탬프가 200보다 크고 400보다 작거나 같은(이 두 CFP의 결합 범위) 트랜잭션을 포함하는 새 CFP를 만듭니다. 범위가 CFP (500, 600]인 다른 CFP가 표시되고 트랜잭션 범위 (200, 400]에 대한 비어 있지 않은 델타 파일은 원본 CFP에서 여러 행 삭제와 같은 트랜잭션 활동과 병합 작업을 동시에 수행할 수 있음을 나타냅니다.  
  
 ![다이어그램에서는 메모리 최적화 테이블 파일 그룹을 보여 줍니다.](../../relational-databases/in-memory-oltp/media/storagediagram-hekaton.png "다이어그램에서는 메모리 최적화 테이블 파일 그룹을 보여 줍니다.")  
  
 백그라운드 스레드는 병합 정책에 따라 모든 닫힌 CFP를 평가한 다음 조건에 맞는 CFP에 대한 하나 이상의 병합 요청을 시작합니다. 이러한 병합 요청은 오프라인 검사점 스레드에서 처리됩니다. 병합 정책 평가는 주기적으로 수행되며 검사점을 닫을 때에도 수행됩니다.  
  
### <a name="ssnoversion-merge-policy"></a>[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 병합 정책  
 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 에서는 다음과 같은 병합 정책을 구현합니다.  
  
-   두 개 이상의 연속하는 CFP를 통합할 수 있는 경우 삭제된 행을 고려한 후 대상 크기의 CFP 하나에 결과 행을 모두 넣을 수 있도록 병합을 예약합니다. 데이터 및 델타 파일의 대상 크기는 위에서 설명한 것처럼 원래 크기에 해당합니다.  
  
-   데이터 파일이 대상 크기를 두 배 초과하고 행이 절반 넘게 삭제된 경우 단일 CFP가 자체적으로 병합될 수 있습니다. 예를 들어 단일 트랜잭션 또는 여러 동시 트랜잭션이 많은 양의 데이터를 삽입하거나 업데이트하는 경우 트랜잭션이 여러 CFP에 걸쳐 있을 수 없기 때문에 데이터 파일이 대상 크기를 초과하게 되면 데이터 파일이 대상 크기보다 커질 수 있습니다.  
  
 다음은 병합 정책에 따라 병합될 CFP를 보여 주는 몇 가지 예입니다.  
  
|인접한 CFP 원본 파일 (채워진 비율)|병합 선택|  
|-------------------------------------------|---------------------|  
|CFP0 (30%), CFP1 (50%), CFP2 (50%), CFP3 (90%)|(CFP0, CFP1)<br /><br /> CFP2는 결과 데이터 파일을 이성적인 크기의 100%를 초과하게 만들므로 선택되지 않습니다.|  
|CFP0 (30%), CFP1 (20%), CFP2 (50%), CFP3 (10%)|(CFP0, CFP1, CFP2) 파일은 왼쪽부터 선택됩니다.<br /><br /> CTP3는 결과 데이터 파일을 이성적인 크기의 100%를 초과하게 만들므로 선택되지 않습니다.|  
|CFP0 (80%), CFP1 (30%), CFP2 (10%), CFP3 (40%)|(CFP1, CFP2, CFP3). 파일은 왼쪽부터 선택됩니다.<br /><br /> CFP0는 CFP1과 결합할 경우 결과 데이터 파일이 이상적인 크기의 100%를 초과하게 되므로 건너뜁니다.|  
  
 사용 가능한 공간이 있는 CFP 중 일부는 병합할 수 없습니다. 예를 들어, 두 개의 인접한 CFP가 60% 채워진 경우 해당 CFP는 병합되지 않고 각 CFP의 스토리지 중 40%는 사용되지 않습니다. 최악의 경우 모든 CFP가 50% 채워진 경우 스토리지의 50%만 사용됩니다. CFP가 병합되지 않아 삭제된 행이 스토리지에 존재할 수 있지만 삭제된 행은 메모리 내 가비지 수집에 의해 메모리에서 이미 제거되었을 수 있습니다. 스토리지 관리와 메모리는 가비지 수집에 종속되지 않습니다. 활성 CFP가 차지하는 스토리지(일부 CFP는 업데이트되지 않음)는 메모리 내 영구 테이블 크기보다 최대 2배 더 클 수 있습니다.  
  
### <a name="life-cycle-of-a-cfp"></a>CFP의 수명 주기  
 CFP 할당을 취소하려면 여러 상태를 전환해야 합니다. 데이터베이스 검사점 및 로그 백업에는 단계를 통해 파일을 전환하는 작업이 필요하고 궁극적으로 더 이상 필요 없는 파일을 정리해야 합니다. 이러한 단계에 대한 자세한 내용은 [sys.dm_db_xtp_checkpoint_files&#40;Transact-SQL&#41;](../../relational-databases/system-dynamic-management-views/sys-dm-db-xtp-checkpoint-files-transact-sql.md)를 참조하세요.  
  
 검사점 후에 강제 로그 백업을 수동으로 수행하여 가비지를 빠르게 수집할 수 있습니다. 프로덕션 시나리오에서 백업 전략의 일부로 수행되는 자동 검사점 및 로그 백업에서는 수동 작업을 수행할 필요 없이 이러한 단계에서 CFP를 완벽하게 전환합니다. 가비지 수집 프로세스의 영향으로 메모리 최적화 테이블을 포함하는 데이터베이스에 메모리 내 크기에 비해 큰 스토리지가 존재할 수 있습니다. 검사점 및 로그 백업이 발생하지 않는 경우 검사점 파일의 디스크상 공간이 계속 증가합니다.  
  
## <a name="see-also"></a>참고 항목  
 [메모리 최적화 개체에 대한 스토리지 만들기 및 관리](../../relational-databases/in-memory-oltp/creating-and-managing-storage-for-memory-optimized-objects.md)  
  
  
